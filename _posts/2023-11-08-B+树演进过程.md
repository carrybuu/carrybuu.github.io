---
layout:     post
title:      【转载】从二叉查找树到B*树，一文搞懂搜索树的演进！
subtitle:   从二叉查找树到B*树，一文搞懂搜索树的演进！
date:       2023-11-08
author:     Buu
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - mysql
---

## 前言


转载：https://z.itpub.net/article/detail/19FBA84CC9A43DDCFF62033D3F8A8DAB

本文从二分查找讲起，讲解了BST、AVL、红黑树、B树、B+树后到B*树的演进过程，知其所以然！

在计算机中有一些数据结构总是与数据的查找分不开，比如二叉查找树（Binary Search Tree）、红黑树、B树、B+树等等数据结构。你可曾想过为什么会有这么多种用于搜索的数据结构？为什么红黑树结构在计算机中内存中被广泛应用？为什么MySQL多种数据引擎都选择B+树作为其索引实现？为什么Redis要使用跳表？

带着这些问题，这篇文章我们探讨一下这些数据结构在实际中的应用以及针对于存在的问题产生的演进。


## 正文

### 二分查找

对于查找数据，不得不提的一种基础算法就是二分法，很多数据结构的查找算法核心思想都是二分法，其查找效率也经常会用来和二分法来做对比。二分法的时间复杂度为**O(logN)**，这是一个非常的时间复杂度，其效率仅次于常数时间复杂度 **O(1)**。

二分查找的实现思路是这样的：

- 1、对数据集进行排序
- 2、找到数据集的中间节点，判断是否为查找的值，等于直接返回。
- 3、根据与中间节点大小的比较结果，确定收缩查找区间范围是中间节点的左边还是右边。
- 4、重复上述 2、3 过程继续查找。

从其实现思路来看，有两个点很重要：一是可以保证数据的有序性，二是适合进行数据分段存储，方便缩小区间查找。所以根据这种思路，演化出了两个不同的路线，`树`和`跳表`两种数据结构。


### 二叉搜索树BST

二叉搜索树(BST，Binary Search Tree)（又叫二叉查找树）是一棵空树，或者是具有下列性质的二叉树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
- 它的左、右子树也分别为二叉排序树。

![图片1](/img/b+tree1.jpg)


#### 二叉搜索树的问题

二叉搜索树符合了使用二分法查询数据的要求，但是有个问题：因为插入顺序的不同，二叉树的高度不稳定，极端情况下可能变成链表（就是插入的数据是有序的，递增或者递减）。这就成了线性查询，时间复杂度多变成O(n)，查询效率不稳定。

为了解决这个问题，就产生了各种树的平衡算法，保证树的节点高度不会差太多。所以就有了AVL树（平衡二叉树）和红黑树等新的数据结构。

现在我们有一个搜索条件比较多的查询语句，它的执行计划如下：


### AVL树

平衡二叉树全称叫做平衡二叉搜索（排序）树，AVL树是早的平衡二叉树之一。

为了解决一般的二叉搜索树存在的问题，即根节点到叶子结点的高度相差太多，查询效率不问题，并且极端情况有成为链表的可能。所以AVL树具有以下特点：

- 它是一棵空树或它的左右两个子树的高度差的值不超过1，
- 左右两个子树 也都是一棵平衡二叉树。
- 在AVL树中，任何节点的两个子树的高度大差别为 1 ，所以它也被称为平衡二叉树 。

![图片2](/img/b+tree2.jpg)

AVL树查找、插入和删除在平均和坏情况下都是O(LogN)。

> AVL 什么意思 ？AVL 是大学教授 G.M. Adelson-Velsky 和 E.M. Landis 名称的缩写，他们提出的平衡二叉树的概念，为了纪念他们，将 平衡二叉树 称为 AVL树。


与普通二叉搜索树的区别的是，它在插入和删除节点的时候，会根据需要进行左旋或者右旋，来保证二叉树的平衡，示意图如下。这不是本文的讨论重点，感兴趣自己可以研究。

![图片3](/img/b+tree3.gif)

![图片4](/img/b+tree4.gif)

#### AVL树的问题
AVL树高度的平衡情况固然很好，但这是有代价的。为了维持平衡，其旋转是非常耗时的。

AVL实现平衡的关键在于旋转操作：插入和删除可能破坏二叉树的平衡，此时需要通过一次或多次树旋转来重新平衡这个树。当插入数据时，多只需要两次旋转(单旋转或双旋转)；但是当删除数据时，会导致树失衡，AVL需要维护从被删除节点到根节点这条路径上所有节点的平衡，旋转的量级为O(lgn)。

由于旋转的耗时，AVL树在删除数据时效率很低；在删除操作较多时，维护平衡所需的代价可能高于其带来的好处，因此AVL实际使用并不广泛。

场景：windows对进程地址空间的管理用到了AVL树。

针对于这种情况，红黑树对其做了优化。

#### 红黑树RB-Tree


红黑树是一种自平衡的二叉查找树，是一种高效的查找树。它是由 Rudolf Bayer 于1978年发明，在当时被称为平衡二叉 *B 树(symmetric binary B-trees)。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的红黑树。红黑树具有良好的效率，它可在 O(logN) 时间内完成查找、增加、删除等操作。

红黑树是一种接近平衡的二叉树（说它是接近平衡因为它并没有像AVL树的平衡因子的概念，它只是靠着满足红黑节点的5条性质来维持一种接近平衡的结构，进而提升整体的性能，并没有严格的卡定某个平衡因子来维持平衡）。

特性
一棵红黑树同时满足以下特性：

- 节点是红色或黑色
- 根是黑色
- 叶子节点（外部节点，空节点）都是黑色，这里的叶子节点指的是底层的空节点（外部节点），下图中的那些null节点才是叶子节点，null节点的父节点在红黑树里不将其看作叶子节点
- 红色节点的子节点都是黑色
 - 红色节点的父节点都是黑色
 - 从根节点到叶子节点的所有路径上不能有 2 个连续的红色节点
- 从任一节点到叶子节点的所有路径都包含相同数目的黑色节点

![图片5](/img/b+tree5.jpg)

红黑树的查找，插入和删除操作，时间复杂度都是O(logN)。


红黑树解决了AVL树什么问题
1.AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡
2.在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣
3.红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，整体性能优于AVL。红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决
4.红黑树的红黑规则，保证坏的情况下，也能在O(log 2N)时间内完成查找操作。

红黑树和AVL树的效率对比：
1.如果插入一个node引起了树的不平衡，AVL树和红黑树都是多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而红黑树多只需3次旋转，只需要O(1)的复杂度。
2.其次，AVL树的结构相较红黑树来说更为平衡，在插入和删除node更容易引起Tree的不平衡，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，红黑树在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。
3.map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，红黑树的统计性能是高于AVL的。

坏情况下，AVL树有多O(logN)次旋转，而红黑树多三次。


### 参考
- [MySQL—optimizer trace By 小龙
](https://www.rsthe.com/archives/mysqloptimizertrace)